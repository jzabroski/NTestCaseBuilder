using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.FSharp.Collections;
using NUnit.Framework;
using NTestCaseBuilder;

namespace $rootnamespace$.Samples.NTestCaseBuilder
{
    ///<summary>
    ///  Test fixture for class 'SortingAlgorithmModule'.
    ///</summary>
    [TestFixture]
    public class TestSortingAlgorithm
    {
        ///<summary>
        ///  A test case to apply sorting to. Provides a sequence of integers in some unspecified order
        ///  - may or may not be sorted in ascending order. Some of the integers in the sequence may be
        ///  duplicated; the duplicates may or may not be adjacent to each other.
        ///  The sequence is generated by permuting a sequence of integers that is known by construction
        ///  to be monotonic increasing, with any duplicates arranged into runs of adjacent duplicated
        ///  values. This base sequence is also made available to check the expected results from any sorting
        ///  algorithm.
        ///</summary>
        public class TestCase
        {
            ///<summary>
            ///  Constructor for use by synthesizing factory.
            ///</summary>
            ///<param name = "leastItemInSequence">The lowest value that starts off <cref>OriginalMonotonicIncreasingSequence</cref></param>
            ///<param name = "nonNegativeDeltas">Sequence of non-negative deltas that will be used to build up <cref>OriginalMonotonicIncreasingSequence</cref></param>
            ///<param name = "permutation">A permutation that is used to shuffle <cref>OriginalMonotonicIncreasingSequence</cref> to give <cref>PermutedSequence</cref></param>
            public TestCase(Int32 leastItemInSequence, IEnumerable<UInt32> nonNegativeDeltas,
                            Permutation<Int32> permutation)
            {
                var originalMonotonicIncreasingSequence = new List<Int32>();

                var runningSum = leastItemInSequence;

                foreach (var nonNegativeDelta in nonNegativeDeltas)
                {
                    originalMonotonicIncreasingSequence.Add(runningSum);
                    runningSum += (Int32) nonNegativeDelta;
                }

                originalMonotonicIncreasingSequence.Add(runningSum);

                OriginalMonotonicIncreasingSequence = originalMonotonicIncreasingSequence;

                PermutedSequence = permutation(originalMonotonicIncreasingSequence);
            }

            ///<summary>
            ///  Parameterless constructor that represents the trivial empty sequence case.
            ///</summary>
            public TestCase()
            {
                OriginalMonotonicIncreasingSequence = new List<Int32>();

                PermutedSequence = new List<Int32>();
            }

            /// <summary>
            ///   The sequence to be used as input to a sorting algorithm.
            /// </summary>
            public IEnumerable<Int32> PermutedSequence { get; set; }

            ///<summary>
            ///  The expected result of sorting <cref>PermutedSequence</cref>.
            ///</summary>
            public IEnumerable<Int32> OriginalMonotonicIncreasingSequence { get; set; }
        }

        private static TypedFactory<TestCase> BuildTestCaseFactory()
        {
            var factoryForLeastItemInSequence = TestVariable.Create(Enumerable.Range(-3, 10));

            const int maximumNumberOfDeltas = 5;

            var factoryForNonNegativeDeltasAndPermutation =
                Interleaving.Create(
                    from numberOfDeltas in Enumerable.Range(0, 1 + maximumNumberOfDeltas)
                    select BuildNonNegativeDeltasAndPermutationFactory(numberOfDeltas));

            var testCaseFactoryForTrivialCase = Singleton.Create(new TestCase());

            var testCaseFactoryForNonTrivialCases =
                Synthesis.Create(factoryForLeastItemInSequence,
                                 factoryForNonNegativeDeltasAndPermutation,
									(leastItemInSequence, nonNegativeDeltasAndItsPermutation) =>
										new TestCase(leastItemInSequence,
													 nonNegativeDeltasAndItsPermutation.Item1,
													 nonNegativeDeltasAndItsPermutation.Item2));

            return
                Interleaving.Create(new[]
										{
											testCaseFactoryForTrivialCase,
											testCaseFactoryForNonTrivialCases
										});
        }

        private static TypedFactory<Tuple<FSharpList<UInt32>, Permutation<Int32>>>
            BuildNonNegativeDeltasAndPermutationFactory(int numberOfDeltas)
        {
            var factoryForNonNegativeDelta =
                TestVariable.Create(from signedDelta in Enumerable.Range(0, 5)
									select (UInt32) signedDelta);
            return
                Synthesis.CreateWithPermutation<UInt32, Int32>(
                    Enumerable.Repeat(factoryForNonNegativeDelta, numberOfDeltas));
        }

        ///<summary>
        ///  Parameterised unit test for <cref>SortingAlgorithmModule.SortWithBug</cref>.
        ///</summary>
        ///<remarks>
        ///  This is expected to fail.
        ///</remarks>
        ///<param name = "testCase"></param>
        public static void
            ParameterisedUnitTestForReassemblyOfPermutedMonotonicIncreasingSequenceByBuggySortingAlgorithm(
            TestCase testCase)
        {
            Console.WriteLine("[{0}]", String.Join(", ", testCase.PermutedSequence));

            var sortedSequence = SortingAlgorithmModule.SortWithBug(testCase.PermutedSequence);

            Assert.IsTrue(sortedSequence.SequenceEqual(testCase.OriginalMonotonicIncreasingSequence));
        }

        ///<summary>
        ///  Parameterised unit test for <cref>SortingAlgorithmModule.SortThatWorks</cref>.
        ///</summary>
        ///<remarks>
        ///  This is expected to succeed.
        ///</remarks>
        ///<param name = "testCase"></param>
        public static void
            ParameterisedUnitTestForReassemblyOfPermutedMonotonicIncreasingSequenceByCorrectSortingAlgorithm(
            TestCase testCase)
        {
            Console.WriteLine("[{0}]", String.Join(", ", testCase.PermutedSequence));

            var sortedSequence = SortingAlgorithmModule.SortThatWorks(testCase.PermutedSequence);

            Assert.IsTrue(sortedSequence.SequenceEqual(testCase.OriginalMonotonicIncreasingSequence));
        }

        ///<summary>
        ///  Unit test for <cref>SortingAlgorithmModule.SortWithBug</cref>.
        ///</summary>
        [Test]
        public void TestReassemblyOfPermutedMonotonicIncreasingSequenceByBuggySortingAlgorithm()
        {
            var factory = BuildTestCaseFactory();
            const Int32 strength = 3;

            var howManyTestCasesWereExecuted = factory.ExecuteParameterisedUnitTestForAllTypedTestCases(strength,
                                                                                                        ParameterisedUnitTestForReassemblyOfPermutedMonotonicIncreasingSequenceByBuggySortingAlgorithm);

            Console.WriteLine("Executed {0} test cases successfully.", howManyTestCasesWereExecuted);
        }

        ///<summary>
        ///  Unit test for <cref>SortingAlgorithmModule.SortWithBug</cref>.
        ///</summary>
        [Test]
        public void TestReassemblyOfPermutedMonotonicIncreasingSequenceByCorrectSortingAlgorithm()
        {
            var factory = BuildTestCaseFactory();
            const Int32 strength = 3;

            var howManyTestCasesWereExecuted = factory.ExecuteParameterisedUnitTestForAllTypedTestCases(strength,
                                                                                                        ParameterisedUnitTestForReassemblyOfPermutedMonotonicIncreasingSequenceByCorrectSortingAlgorithm);

            Console.WriteLine("Executed {0} test cases successfully.", howManyTestCasesWereExecuted);
        }

        ///<summary>
        ///  Reproduce the test failure from <cref>TestReassemblyOfPermutedMonotonicIncreasingSequenceByBuggySortingAlgorithm</cref>.
        ///</summary>
        [Test]
        public void TestThatQuicklyReproducesTheFailureFromTheBuggyTest()
        {
            const string reproduction =
                // This is cut and paste from the exception thrown by test TestReassemblyOfPermutedMonotonicIncreasingSequenceByBuggySortingAlgorithm.
                "1090764779116129690923515858308014520222336185700694896976936400046940578111983112055989629000774433035533486068550533022472823468733765589962776559338572322298363762860309148125493567586652092021784868479197857245164629966066416639512627980086087576627134771790830306023362551977824458832435182987106754209128418014614913562852866661150091823623905211435301653034234730637078735760034785248360299188556784228883811731867030708810157089826985140720828164015899710277970434700526655869841143488587567038571735998728721968615155191928984106790564279518279784236202537781731978451027142223453012152211253073989894600307113508602425354704208940802187486726344247050643044383538779386086588047296386819900187407750843248679298230390470148566258036534037996311793318879680463434610070481418269047127848420470574825542465106164754099525705315023146132151244594810948490203900377360259817190450316951803352031991828367634047145860899071450373006397713010460342025737576564196555051716252749097546041767306885984085224350667603871622073760866686709528494130862000976104510699941891395624701270417418452613136379719414217847624839262147866173503958080842138125437184629659732639530505165598491096910303286081347443030840058071033060368937580646806001508103784584135702079133404285331477947116358374110455694440440204184429276574878845022435170813455700510704169050420927306762756723633333477366050436408832272352684876210204937558754132057814656123643813621361206799080747009227697833440994857880325308875023817115189138362929244686842676010167047098332216555058218589106272300998139142842786073435052363123157657919517514785815111827532063988013852570411199685264682076517527579189785611470174787686706645612790791306327171422236982411154222013578243741335135432777850456144984807570819125052698552918451662366609363161784682438591929843299156008974189438741474564886293747664951012808715212017727847576770093689928974034612144074850873524935540529109220855520056017820375679165311079594524906619767976405533398767463453261402545852985213001983598298242283233652310501081702893007187954807637108530014145949047022299418578265436207150629805114182837632289192857042533748858738131634329097215400694184607707302790615984654443860754251746376094888872139304189125813996350112238801493469111659204711764664019704047524471961789039385123078840459136274769466802830356174381017210484260909602216049999700776061391638331991328238370294036156805519568063372047076046644340281168625664";

            var factory = BuildTestCaseFactory();

            factory.ExecuteParameterisedUnitTestForReproducedTypedTestCase(
                ParameterisedUnitTestForReassemblyOfPermutedMonotonicIncreasingSequenceByBuggySortingAlgorithm,
                reproduction);
        }
    }
}